/* parser.c - a lexical analyzer system and parser for simple
 arithmetic expressions */
//  Adapted from Concepts of Programming Languages - Robert W. Sebesta
// Author of Edit: Saurav Keshari Aryal

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>

/* Global declarations */

/* Variables */
int charClass;
char lexeme [100];
char lastChar;
char nextChar;
int lexLen;
int token;
int nextToken;
FILE *in_fp, *fopen();

size_t len = 0;
ssize_t read;
char* line = NULL;
int indexChar;
int lastIndex;
int row_num=0;
int col_num=1;

/* Function declarations */
void addChar();
void getChar();
void getNonBlank();
int lex();
int factor();
int expr();
int term();
void error();

/* Character classes */
#define LETTER 0
#define DIGIT 1
#define UNKNOWN 99

/* Token codes */
#define INT_LIT 10
#define IDENT 11
#define ASSIGN_OP 20
#define ADD_OP 21
#define SUB_OP 22
#define MULT_OP 23
#define DIV_OP 24
#define LEFT_PAREN 25
#define RIGHT_PAREN 26


/* main driver */
int main(int argc, char *argv[]) {
 /* argc should be 2 for correct execution */
	if (argc != 2){
        printf("usage:\n./parser filename\n\n");
        exit(0);
    }
    else {
	/* Open the input data file and process its contents */
		if ((in_fp = fopen(argv[1], "r")) == NULL)
			printf("ERROR - cannot open %s\n", argv[1]);
		else {
			while ((read = getline(&line, &len, in_fp)) != -1) {
				col_num = 1;
				row_num++;
				indexChar = 0;
				getChar();
				if(line != NULL){
					do {
						lex();	
						if (expr() == -1)
						 	break;
					} while (nextToken != EOF);
				}
			    printf("\n\n");
			}	
		}
	}
	return 0;
}


/* lookup - a function to lookup operators and parentheses
and return the token */
int lookup(char ch) {
	switch (ch) {
		case '(':
			addChar();
			nextToken = LEFT_PAREN;
			break;
		case ')':
			addChar();
			nextToken = RIGHT_PAREN;
			break;
		case '+':
			addChar();
			nextToken = ADD_OP;
			break;
		case '-':
			addChar();
			nextToken = SUB_OP;
			break;
		case '*':
			addChar();
			nextToken = MULT_OP;
			break;
		case '/':
			addChar();
			nextToken = DIV_OP;
			break;
		case '=':
			addChar();
			nextToken = ASSIGN_OP;
			break;
		default:
			addChar();
			nextToken = EOF;
			break;
	}
	return nextToken;
}


/* error
prints the error and where it occured while parsing
*/
void error(){
	printf("Syntax ERROR! in line %d at column %d\n", row_num, col_num);
	char *read;
	read = (char *) malloc(indexChar);
	memset(read, '\0', sizeof(read));
	strncpy(read, line, lastIndex-1);
	printf("While parsing %s\nError at character %c\n", read, lastChar);
	free(read);
}


/* factor
Parses strings in the language generated by the rule:
<factor> -> id | int_constant | ( <expr )
*/
int factor() {
	printf("Enter <factor>\n");
	/* Determine which RHS */
	if (nextToken == IDENT || nextToken == INT_LIT)
		/* Get the next token */
		lex();
	/* If the RHS is ( <expr>), call lex to pass over the
	left parenthesis, call expr, and check for the right
	parenthesis */
	else {
		if (nextToken == LEFT_PAREN) {
			lex();
			expr();
			if (nextToken == RIGHT_PAREN)
				lex();
			else {
				error();
			    return -1;
			}
		} /* End of if (nextToken == ... */
		/* It was not an id, an integer literal, or a left
		parenthesis */
		else {
			error();
			return -1;
		}
	} /* End of else */
	printf("Exit <factor>\n");
	return 0;
} /* End of function factor */	


/* term
Parses strings in the language generated by the rule:
<term> -> <factor> {(* | /) <factor>)
*/
int term() {
	printf("Enter <term>\n");
	/* Parse the first factor */
	if (factor() == -1)
		return -1;
	/* As long as the next token is * or /, get the
	next token and parse the next factor */
	while (nextToken == MULT_OP || nextToken == DIV_OP) {
		lex();
		if (factor() == -1)
			return -1;
	}
	printf("Exit <term>\n");
	return 0;
} /* End of function term */



/* expr
Parses strings in the language generated by the rule:
<expr> -> <term> {(+ | -) <term>}
*/
int expr() {
	printf("Enter <expr>\n");
	/* Parse the first term */
	if (term() == -1)
		return -1;
	/* As long as the next token is + or -, get
	the next token and parse the next term */
	while (nextToken == ADD_OP || nextToken == SUB_OP) {
		lex();
		if (term() == -1)
			return -1;
	}
	printf("Exit <expr>\n");
	return 0;
} /* End of function expr */


/* addChar - a function to add nextChar to lexeme */
void addChar() {
	if (lexLen <= 98) {
		lexeme[lexLen++] = nextChar;
		lexeme[lexLen] = 0;
	}
	else
		printf("Error - lexeme is too long \n");
}


/* getChar - a function to get the next character of
input and determine its character class */
void getChar() {

	if (line[indexChar] != '\n' && line[indexChar] != '\0') {
		col_num++;
		nextChar = line[indexChar ++];
		if (isalpha(nextChar))
			charClass = LETTER;
		else if (isdigit(nextChar))
			charClass = DIGIT;
			else charClass = UNKNOWN;
	}
	else
		charClass = EOF;
}


/* getNonBlank - a function to call getChar until it
returns a non-
whitespace
character */
void getNonBlank() {
	while (isspace(nextChar))
		getChar();
}


/* lex - a simple lexical analyzer for arithmetic
expressions */
int lex() {
	lexLen = 0;
	getNonBlank();
	lastChar = nextChar;
	lastIndex = col_num;
	switch (charClass) {
		/* Parse identifiers */
		case LETTER:
			addChar();
			getChar();
			while (charClass == LETTER || charClass == DIGIT) {
				addChar();
				getChar();
			}
			nextToken = IDENT;
			break;
		/* Parse integer literals */
		case DIGIT:
			addChar();
			getChar();
			while (charClass == DIGIT) {
				addChar();
				getChar();
			}
			nextToken = INT_LIT;
			break;
		/* Parentheses and operators */
		case UNKNOWN:
			lookup(nextChar);
			getChar();
			break;
		/* EOF */
		case EOF:
			nextToken = EOF;
			lexeme[0] = 'E';
			lexeme[1] = 'O';
			lexeme[2] = 'F';
			lexeme[3] = 0;
		break;
	} /* End of switch */
	printf("Next token is: %d, Next lexeme is %s\n", nextToken, lexeme);
	return nextToken;
} /* End of function lex */

